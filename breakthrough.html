<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ðŸš€ BREAKTHROUGH Monitor</title>
  <style>
    body { background:#0d1117; color:#eee; font-family:Inter,Arial,sans-serif; margin:0; }
    header { display:flex; align-items:center; justify-content:space-between; padding:10px 20px; background:#161b22; }
    h1 { font-size:20px; margin:0; }
    select,input,button { background:#21262d; color:#eee; border:1px solid #30363d; border-radius:6px; padding:4px 8px; }
    button.ghost { background:none; border:none; color:#58a6ff; cursor:pointer; }
    .controls { display:flex; gap:10px; align-items:center; }
    .grid { display:flex; flex-direction:column; gap:12px; padding:12px; }
    .row { display:grid; grid-template-columns:220px 1fr 1fr; gap:12px; background:#161b22; border-radius:8px; padding:8px; }
    .cell { background:#0d1117; border-radius:6px; padding:6px; overflow:hidden; }
    .ticker { font-size:18px; font-weight:600; }
    .name { font-size:13px; color:#aaa; }
    .chips { display:flex; flex-wrap:wrap; gap:4px; margin-top:4px; }
    .chip { background:#30363d; border-radius:12px; padding:2px 6px; font-size:12px; }
    iframe { width:100%; height:340px; border:0; transform:scale(0.95); transform-origin:top; }
    .metrics{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:6px 12px;font-size:12px;color:#aaa;margin-top:6px}
    .metrics b{color:#eee;font-weight:700}
    #gauge { width:200px; height:100px; position:relative; margin:auto; }
    #needle { width:2px; height:90px; background:red; position:absolute; bottom:0; left:50%; transform-origin:bottom center; }
  </style>
</head>
<body>
  <header>
    <h1>ðŸš€ BREAKTHROUGH Monitor</h1>
    <div class="controls">
      <label>Geo <select id="geo"><option value="US">US</option><option value="">Worldwide</option></select></label>
      <label>Trends <select id="trendTime"><option value="today 1-m">Past 30d</option><option value="today 3-m">3M</option><option value="today 12-m">12M</option></select></label>
      <label>Charts <select id="range"><option value="1M">1M</option><option value="3M">3M</option><option value="6M">6M</option><option value="12M" selected>12M</option><option value="ALL">ALL</option></select></label>
      <input id="add" placeholder="Add ticker e.g. PLTR" /> <button id="addBtn">Add</button>
    </div>
    <div id="gauge">
      <div id="needle"></div>
      <div id="fngVal" style="position:absolute;bottom:0;left:50%;transform:translateX(-50%);font-size:14px;"></div>
      <div id="fngSrc" style="position:absolute;top:0;left:50%;transform:translateX(-50%);font-size:11px;color:#aaa;"></div>
    </div>
  </header>

  <div id="table" class="grid"></div>

<script type="module">
  const FMP_KEY = "CnZ2WdgFKH9JQxlqxKNvBg8rHbe9wvnN"; // free key that works immediately
const API_FMP = "https://financialmodelingprep.com/api/v3";
// ---- FMP client: throttle, retry (429), and in-memory cache ----
const FMP = {
  base: API_FMP,
  key: FMP_KEY,
  cache: new Map(),        // url -> { t, v }
  chain: Promise.resolve(),// serialize calls
  lastAt: 0,
  async get(path, ttlMs = 60000) {
    const url = `${this.base}${path}${path.includes('?') ? '&' : '?'}apikey=${this.key}`;
    const now = Date.now();
    const cached = this.cache.get(url);
    if (cached && (now - cached.t) < ttlMs) return cached.v;

    // queue + minimum gap (free plan is sensitive)
    const minGap = 350; // ms between calls
    this.chain = this.chain.then(async () => {
      const wait = Math.max(0, minGap - (Date.now() - this.lastAt));
      if (wait) await new Promise(r => setTimeout(r, wait));
      this.lastAt = Date.now();
    });
    await this.chain;

    // fetch with backoff on 429/503
    let tries = 3, back = 500, lastTxt = '';
    while (tries--) {
      const res = await fetch(url);
      const txt = await res.text(); lastTxt = txt;
      if (res.ok) {
        const data = txt ? JSON.parse(txt) : null;
        this.cache.set(url, { t: Date.now(), v: data });
        return data;
      }
      if (res.status === 429 || res.status === 503) {
        await new Promise(r => setTimeout(r, back));
        back = Math.min(2000, Math.round(back * 1.8));
        continue;
      }
      throw new Error(`FMP ${res.status}: ${txt.slice(0,120)}`);
    }
    throw new Error(`FMP rate-limited: ${lastTxt.slice(0,120)}`);
  }
};

const WATCHLIST=[
{ ticker:'PLTR', name:'Palantir', exchange:'NYSE', trendsQuery:'Palantir' },
{ ticker:'QSI', name:'Quantum-Si', exchange:'NASDAQ', trendsQuery:'Quantum-Si' },
{ ticker:'APLD', name:'Applied Digital', exchange:'NASDAQ', trendsQuery:'Applied Digital' }
];


const state = { rows:[], range:'12M', geo:'US', trendTime:'today 1-m' };
const table = document.getElementById('table');
// Defaults if not already defined:

const fngVal=document.getElementById('fngVal');
const needle=document.getElementById('needle');
const fngSrc=document.getElementById('fngSrc');

  const volSurge = (quote) => {
  if(!quote || !quote.volume || !quote.avgVolume) return null;
  return (quote.volume / quote.avgVolume > 2) ? "ðŸ”¥ Volume Surge" : null;
};
const momentum = (quote) => {
  if(!quote || !quote.price || !quote.ma20) return null;
  const pct = ((quote.price - quote.ma20) / quote.ma20) * 100;
  return pct > 10 ? `ðŸš€ Momentum +${pct.toFixed(1)}%` : null;
};
  const breakout = (quote) => {
  if(!quote || !quote.price || !quote.high30d) return null;
  return (quote.price >= quote.high30d) ? "ðŸ“ˆ 30d Breakout" : null;
};
  const trendSpike = (trendData) => {
  if(!trendData || trendData.length < 7) return null;
  const last = trendData.slice(-7).reduce((a,b)=>a+b,0)/7;
  const base = trendData.slice(0,7).reduce((a,b)=>a+b,0)/7;
  return (last > base*3) ? "ðŸ”¥ Trend Spike" : null;
};



function setFNG(v,src){
needle.style.transform=`rotate(${ -90 + (v*1.8) }deg)`;
fngVal.textContent=v;
fngSrc.textContent=src||'';
}


(async()=>{ const live=await fetchFearGreed(); if(live){ setFNG(live.value, live.source); } })();


  function tvMiniConfig(ticker){ return { symbol:ticker, width:'100%', height:300, locale:'en', dateRange:state.range, colorTheme:'dark', isTransparent:true, autosize:true }; }
  function safeJSON(obj){ return JSON.stringify(obj).replace(/</g,'\\u003c').replace(/>/g,'\\u003e'); }

  function trendSrc(query){
    const req={ comparisonItem:[{ keyword: query, geo: state.geo, time: state.trendTime }], category:0 };
    const tz=-new Date().getTimezoneOffset();
    const base='https://trends.google.com/trends/embed/explore/TIMESERIES';
    const params=new URLSearchParams({ hl:'en-US', req: JSON.stringify(req), tz: String(tz) });
    return `${base}?${params.toString()}`;
  }

  function makeRow(stock){
    const row=document.createElement('div'); row.className='row';
    const left=document.createElement('div'); left.className='cell sym';
    left.innerHTML=`
        <div><div class="ticker">${stock.ticker}</div><div class="name">${stock.name}</div></div>
        <div class="chips" data-chips><span class="chip">${stock.exchange}</span><span class="chip">Trends: ${stock.trendsQuery||stock.name}</span></div>
        <div class="metrics" data-metrics><div>Loading...</div></div>
        <div class="actions"><button class="ghost" data-remove>Remove</button></div>`;

    const mid=document.createElement('div'); mid.className='cell trends';
    const tFrame=document.createElement('iframe'); tFrame.loading='lazy'; tFrame.src=trendSrc(stock.trendsQuery||stock.name);
    mid.appendChild(tFrame);

    const right=document.createElement('div'); right.className='cell mini';
    const tvbox=document.createElement('div'); tvbox.className='tvbox'; right.appendChild(tvbox);

    row.appendChild(left); row.appendChild(mid); row.appendChild(right);
    table.appendChild(row);

    lazyMountMiniChart(tvbox, `${stock.exchange}:${stock.ticker}`);
    fetchValuation(stock.ticker).then(v=>{ if(v) renderValuation(left, v); else left.querySelector('[data-metrics]').innerHTML='<div>n/a</div>'; });
// Fetch signals and render Breakthrough Strength
    fetchSignals(stock.ticker).then(sig => {
    renderSignals(left, sig);
    row.dataset.score = sig?.score ?? 0;
    resortBySignal();
});
// Value targets (Analyst + Model)
fetchValueTargets(stock.ticker).then(t => {
  renderValueTargets(left, t);
});

    state.rows.push({ el:row, data:stock, tFrame, tvbox });
  }

  function lazyMountMiniChart(container,symbol){
    const mount=()=>{ if(container.dataset.mounted) return; container.dataset.mounted='1'; addTVMini(container, symbol); };
    const io=new IntersectionObserver((entries)=>{ entries.forEach(e=>{ if(e.isIntersecting){ mount(); io.disconnect(); } }); },{rootMargin:'200px'});
    io.observe(container);
  }

  function addTVMini(container,symbol){
    try{
      const script=document.createElement('script'); script.type='text/javascript'; script.src='https://s3.tradingview.com/external-embedding/embed-widget-mini-symbol-overview.js'; script.async=true; script.text=safeJSON(tvMiniConfig(symbol)); container.appendChild(script);
    }catch(e){ console.error('TV embed error', e); }
  }

  document.getElementById('table').addEventListener('click',(e)=>{
    const btn=e.target.closest('[data-remove]'); if(!btn) return;
    const row=btn.closest('.row');
    const sym=row.querySelector('.ticker')?.textContent.trim();
    row.remove();
    state.rows=state.rows.filter(r=>r.data.ticker!==sym);
  });

  document.getElementById('addBtn').addEventListener('click',()=>{
    const input=document.getElementById('add');
    const raw=input.value.trim().toUpperCase();
    if(!raw) return;
    if(state.rows.some(r=>r.data.ticker===raw)) { input.value=''; return; }
    const item={ ticker:raw, name:raw, exchange:'NASDAQ', trendsQuery:raw };
    makeRow(item); input.value='';
  });

  document.getElementById('range').addEventListener('change',e=>{
    state.range=e.target.value;
    state.rows.forEach(r=>{ r.tvbox.innerHTML=''; r.tvbox.removeAttribute('data-mounted'); lazyMountMiniChart(r.tvbox, `${r.data.exchange}:${r.data.ticker}`); });
  });
  document.getElementById('geo').addEventListener('change',e=>{ state.geo=e.target.value; refreshTrends(); });
  document.getElementById('trendTime').addEventListener('change',e=>{ state.trendTime=e.target.value; refreshTrends(); });
  function refreshTrends(){ state.rows.forEach(r=>{ r.tFrame.src=trendSrc(r.data.trendsQuery||r.data.name); }); }

async function fetchFearGreed(){
  try {
    const r = await fetch("https://edition.cnn.com/markets/fear-and-greed");
    if (r.ok){
      const html = await r.text();
      // Try multiple patterns seen on CNN over time
      const m =
        /dial-number[^>]*>(\d{1,3})/i.exec(html) ||
        /Fear\s*&\s*Greed[^\d]*(\d{1,3})/i.exec(html) ||
        /"score"\s*:\s*(\d{1,3})/i.exec(html);
      if (m){
        const v = Math.max(0, Math.min(100, parseInt(m[1], 10)));
        return { value: v, source: "CNN" };
      }
    }
  } catch(e){
    console.error("FNG fetch error", e);
  }
  return null;
}


// --- Value Targets (Analyst + Model) ---

async function fetchValueTargets(ticker){
  try{
    const [qArr, pArr, kArr, ptArr] = await Promise.all([
      FMP.get(`/quote/${encodeURIComponent(ticker)}`,                      15000),
      FMP.get(`/profile/${encodeURIComponent(ticker)}`,                    10*60*1000),
      FMP.get(`/key-metrics-ttm/${encodeURIComponent(ticker)}`,           10*60*1000),
      FMP.get(`/price-target?symbol=${encodeURIComponent(ticker)}`,       10*60*1000)
    ]);

    const quote = Array.isArray(qArr) && qArr[0] ? qArr[0] : {};
    const prof  = Array.isArray(pArr) && pArr[0] ? pArr[0] : {};
    const km    = Array.isArray(kArr) && kArr[0] ? kArr[0] : {};
    const pt    = Array.isArray(ptArr) && ptArr[0] ? ptArr[0] : {};

    const price = Number(quote.price ?? quote.previousClose ?? 0);

    // Analyst values (robust field fallbacks)
    const toNum = x => { const n=Number(x); return Number.isFinite(n)? n : null; };
    const analystMean = toNum(
      pt.targetMean ?? pt.targetConsensus ?? pt.consensus ?? pt.mean ?? null
    );
    const analystMedian = toNum(
      (pt.targetMedian != null) ? pt.targetMedian
      : (pt.targetLow != null && pt.targetHigh != null)
        ? (Number(pt.targetLow) + Number(pt.targetHigh)) / 2
        : null
    );

    // Sector-aware anchors
    const epsTTM = toNum(km.netIncomePerShareTTM ?? km.epsTTM ?? km.epsDilutedTTM);
    const rpsTTM = toNum(km.revenuePerShareTTM);
    const sector = (prof.sector || "").toLowerCase();
    let peAnchor = 20, psAnchor = 3;
    if (sector.includes("software") || sector.includes("internet") || sector.includes("it")) { peAnchor=25; psAnchor=4; }
    else if (sector.includes("semiconductor")) { peAnchor=22; psAnchor=3.5; }
    else if (sector.includes("financial")) { peAnchor=12; psAnchor=2; }
    else if (sector.includes("utilities")) { peAnchor=15; psAnchor=2; }
    else if (sector.includes("energy")) { peAnchor=12; psAnchor=1.5; }
    else if (sector.includes("health")) { peAnchor=18; psAnchor=3; }

    const fairPE = (epsTTM>0) ? epsTTM * peAnchor : null;
    const fairPS = (rpsTTM>0) ? rpsTTM * psAnchor : null;

    let modelFair = null;
    if (fairPE!=null && fairPS!=null) modelFair = 0.6*fairPE + 0.4*fairPS;
    else if (fairPE!=null)            modelFair = fairPE;
    else if (fairPS!=null)            modelFair = fairPS;

    return { price, analystMean, analystMedian, modelFair };
  }catch(e){
    console.error('valueTargets error', e);
    return null;
  }
}



  function toNum(x){ const n=Number(x); return Number.isFinite(n)?n:null; }
}

function renderValueTargets(left, t){
  // Remove old block if exists
  const old = left.querySelector('.targets'); if(old) old.remove();
  const box = document.createElement('div');
  box.className = 'targets';
  box.style.marginTop = '6px';
  box.style.fontSize = '12px';
const cmpChip = (label, val) => {
  if (val==null || !t.price) return `<span class="chip" style="background:#37474f">${label} â€”</span>`;
  const d = (val / t.price - 1) * 100;
  const bg = d>=10 ? '#2e7d32' : d<=-10 ? '#b23c17' : '#8d6e63';
  return `<span class="chip" style="background:${bg}">${label} ${fmt(val)}</span>`;
};

  if(!t){ box.innerHTML = `<b>Value Targets</b> â€” n/a`; left.appendChild(box); return; }

  const fmt = v => (v==null ? 'â€”' : (v<10 ? v.toFixed(2) : v.toFixed(1)));
  const tag = (label, val) => `<span class="chip" style="background:#37474f">${label} ${fmt(val)}</span>`;

  // Simple verdict vs our model
  let verdict = '';
  if (t.modelFair!=null && t.price>0){
    const diff = (t.modelFair / t.price - 1) * 100;
    verdict = diff>10 ? `<span class="chip" style="background:#2e7d32">Undervalued +${diff.toFixed(0)}%</span>`
           : diff<-10 ? `<span class="chip" style="background:#b23c17">Overpriced ${diff.toFixed(0)}%</span>`
                      : `<span class="chip" style="background:#8d6e63">Near Fair ${diff.toFixed(0)}%</span>`;
  }

  box.innerHTML = `<b>Value Targets</b> 
${cmpChip('Analyst Mean', t.analystMean)}
${cmpChip('Analyst Median', t.analystMedian)}
${cmpChip('Model Fair', t.modelFair)}

    ${verdict}`;
  left.appendChild(box);
}


async function fetchValuation(ticker){
  try {
    const [prof, km, ratio] = await Promise.all([
      FMP.get(`/profile/${encodeURIComponent(ticker)}`,              10*60*1000), // 10m
      FMP.get(`/key-metrics-ttm/${encodeURIComponent(ticker)}`,     10*60*1000),
      FMP.get(`/ratios-ttm/${encodeURIComponent(ticker)}`,          10*60*1000),
    ]);

    const p0 = Array.isArray(prof)  && prof[0]  ? prof[0]  : {};
    const k0 = Array.isArray(km)    && km[0]    ? km[0]    : {};
    const r0 = Array.isArray(ratio) && ratio[0] ? ratio[0] : {};

    const mcap = p0.mktCap ? `$${Math.round(p0.mktCap/1e9)}B` : null;
    const pe   = k0.peTTM ?? r0.peRatioTTM ?? null;
    const ps   = k0.priceToSalesTTM ?? r0.priceToSalesRatioTTM ?? null;
    const evs  = k0.enterpriseValueOverRevenueTTM ?? null;
    const eve  = r0.enterpriseValueOverEBITDATTM ?? null;
    const de   = r0.debtEquityRatioTTM ?? null;
    const roe  = r0.returnOnEquityTTM ?? null;

    return { mcap, pe, ps, evs, eve, de, roe };
  } catch(e){
    console.error("Valuation fetch error", e);
    return null;
  }
}


function renderValuation(left, v){
const m=left.querySelector('[data-metrics]');
if(!m) return;
m.innerHTML='';
const add=(k,val)=>{
if(val==null) return;
const d=document.createElement('div');
d.style.display='flex';
d.style.justifyContent='space-between';
d.innerHTML=`<span>${k}</span><b>${typeof val==='number'? Number(val.toFixed(2)) : val}</b>`;
m.appendChild(d);
};
add('MCap', v.mcap);
add('P/E', v.pe);
add('P/S', v.ps);
add('EV/S', v.evs);
add('EV/EBITDA', v.eve);
add('Debt/Equity', v.de);
add('ROE %', v.roe);
}


WATCHLIST.forEach(makeRow);
  // ---------- Breakthrough signal engine ----------
async function fetchSignals(ticker){
  try{
    const [qArr, hist] = await Promise.all([
      FMP.get(`/quote/${encodeURIComponent(ticker)}`,                         15000),      // 15s
      FMP.get(`/historical-price-full/${encodeURIComponent(ticker)}?timeseries=60&serietype=line`, 60*60*1000) // 1h
    ]);
    const q = Array.isArray(qArr) && qArr[0] ? qArr[0] : {};
    const closes = (hist?.historical||[]).map(d=>Number(d.close)).filter(Number.isFinite);

    const price = Number(q.price ?? q.previousClose ?? closes.at(-1) ?? 0);
    const volume = Number(q.volume ?? 0);
    const avgVolume = Number(q.avgVolume ?? q.avgVolume10days ?? q.avgVolume2weeks ?? 0);

    const last20 = closes.slice(-20);
    const ma20 = last20.length ? last20.reduce((a,b)=>a+b,0)/last20.length : null;
    const high30d = closes.slice(-30).reduce((m,v)=>Math.max(m,v), -Infinity);
    const fiveAgo = closes.slice(-6, -5)[0];
    const chg5d = (Number.isFinite(fiveAgo) && fiveAgo>0) ? (price/fiveAgo - 1) : null;

    const clamp=x=>Math.max(0,Math.min(1,x));
    const volScore = (volume>0 && avgVolume>0) ? clamp((volume/avgVolume - 1)/1) : 0;   // 2x avg -> 1
    const momScore = (ma20? clamp((price/ma20 - 1)/0.10): 0);                            // +10% over MA20 -> 1
    const brkScore = (Number.isFinite(high30d)? (price>=high30d?1: clamp((price-(high30d*0.97))/(high30d*0.03))):0); // within 3% of 30d high

    const score01 = 0.35*volScore + 0.35*momScore + 0.30*brkScore;
    const score = Math.round(score01*100);

    return { price, volume, avgVolume, ma20, high30d, chg5d, volScore, momScore, brkScore, score };
  }catch(e){ console.error('signals error', e); return null; }
}


function renderSignals(left, sig){
const old = left.querySelector('.sig');
if(old) old.remove();


const box = document.createElement('div');
box.className = 'sig';
box.style.marginTop = '6px';
box.style.fontSize = '12px';


const chip = (txt,cls='') => `<span class="chip ${cls}" style="background:#2e7d32">${txt}</span>`;
const chips=[];


if(!sig){ left.appendChild(box); return; }
if(sig.volScore>=0.7) chips.push(chip('ðŸ”¥ Vol Surge'));
if(sig.momScore>=0.7) chips.push(chip('ðŸš€ Momentum'));
if(sig.brkScore>=0.9) chips.push(chip('ðŸ“ˆ Breakout'));


chips.push(chip(`Signal ${sig.score}`,'warn'));


box.innerHTML = `<b>Signals</b> ${chips.join(' ')}`;
left.appendChild(box);
}


function resortBySignal(){
const rows=[...document.getElementById('table').children];
rows.sort((a,b)=> (Number(b.dataset.score||0) - Number(a.dataset.score||0)) );
rows.forEach(r=>document.getElementById('table').appendChild(r));
}
</script>
</body>
</html>
